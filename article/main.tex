
\documentclass[a4paper,12pt]{article}

\usepackage{cmap}            
\usepackage[T1,T2A]{fontenc}       
\usepackage[utf8]{inputenc}        
\usepackage[english,russian]{babel}
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} % AMS
\usepackage[miktex]{gnuplottex}
\usepackage{tikz}
\usepackage{mathpazo}

\usepackage[most]{tcolorbox} % для управления цветом

% Параметры страницы: 1см от правого края и 2см от остальных.
\hoffset=0mm
\voffset=0mm
\textwidth=188mm        % ширина текста
\oddsidemargin=-15mm   % левое поле 25.4 - 15.4 = 10 мм
\textheight=260mm       % высота текста 297 (A4) - 40
\topmargin=-15.4mm      % верхнее поле (10мм)
\headheight=5mm      % место для колонтитула
\headsep=2mm          % отступ после колонтитула
\footskip=7.5mm         % отступ до нижнего колонтитула


% НАСТРОЙКИ

\definecolor{block-gray}{gray}{0.97} % уровень прозрачности (1 - максимум)


\definecolor{textgray}{gray}{0.3} % уровень прозрачности (1 - максимум)


\definecolor{textblack}{gray}{0.15} % уровень прозрачности (1 - максимум)

\definecolor{formulacolor}{RGB}{0, 77, 64}


\newtcolorbox{grayback}{coltext=textblack, colback=block-gray,grow to right by= -5mm,grow to left by= -5mm,
	boxrule=0pt,boxsep=0pt,breakable} % настройки области с изменённым фоном




\makeatletter
\def\colorizemath #1#2{%
	\expandafter\mathchardef\csname orig:math:#1\endcsname\mathcode`#1
	\mathcode`#1="8000
	\toks@\expandafter{\csname orig:math:#1\endcsname}%
	\begingroup
	\lccode`~=`#1
	\lowercase{%
		\endgroup
		\edef~{{\noexpand\color{#2}\the\toks@}}}%
}
\@for\@tempa:=a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\do{%
	\expandafter\colorizemath\@tempa{formulacolor}}
\@for\@tempa:=A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z\do{%
	\expandafter\colorizemath\@tempa{formulacolor}}
\@for\@tempa:=0,1,2,3,4,5,6,7,8,9\do{%
	\expandafter\colorizemath\@tempa{formulacolor}}
\makeatother

\everymath{\color{formulacolor}}
\everydisplay{\color{formulacolor}}


\begin{document} 
	\color{textgray}
	\input{head.tex}
	
	\begin{large}
		\begin{flushright}
			\fbox{
				\textbf{Краткая суть}
			}
		\end{flushright}
	\end{large}
	
	\begin{grayback}
	В нескольких предложениях опишите то, о чем вы будете повествовать. Что из себя представляет тема вашей работы и каким образом вы будете раскрывать этот вопрос.
	\end{grayback}
	   
	В качестве темы для курсовой работы мной была выбрана "Выявление токсичного контента на портале для обмена знаниями Quora". Моя задача состоит в том, чтобы разработать универсальную, расширяемую многофункциональную систему для распознавания и отсеивания токсичного контента для улучшения пользовательского опыта работы с порталом Quora.
	
	\begin{large}
		\begin{flushright}
			\fbox{
				\textbf{Актуальность проблемы}
			}
		\end{flushright}
	\end{large}
	
	\begin{grayback}
	Введение для курсовой работы обязательно должно описывать актуальность проблемы. Это формальность, но почти все студенческие работы о правилах и рамках, а не о свободной форме изложения мыслей учащегося. Иногда приходится забывать о креативе и писать «как положено»
	\end{grayback}
	
	Актуальность и своевременность поднимаемой проблемы не поддается сомнению: каждый из нас каждый день сталкивается с неподобающим поведением со стороны других пользователей интернета. В основном, это вызвано анонимностью оставленных комментариев, однако мы не пойдем по пути деанонимизации, а будем бороться с проблемой путем автоматического определения и удаления спорного контента.
	
    \begin{large}
        \begin{flushright}
        	\fbox{
        		\textbf{Задачи курсовой}
        	}
        \end{flushright}
    \end{large}
	
	\begin{grayback}
	Вам необходимо поставить задачи, которые вы будете раскрывать по мере написания материала. Задачи должны быть поставлены в соответствии с целью.

    По сути, задачи это небольшой план, исходя из которого, вы пишите курсач.
	\end{grayback}
	
\begin{itemize}
    \item Разработать масштабируемую и универсальную архитектуру проекта, которая бы поддерживала подключение различных математических моделей, преобразователей данных, статистических инструментов и т.п.
    \item Используя разработанную структуру подобрать подходящую математическую модель, которая бы хорошо решала поставленную задачу.
\end{itemize}
	
	   \begin{large}
        \begin{flushright}
        	\fbox{
        		\textbf{Цель}
        	}
        \end{flushright}
    \end{large}
	
	\begin{grayback}
	Цель — это итог, то к чему вы стремитесь при изучении поставленной вами проблемы.
	\end{grayback}
	
	В качестве конечной цели я вижу достижение процента правильно выявленного контента в 0.7.
	
		
	   \begin{large}
        \begin{flushright}
        	\fbox{
        		\textbf{Объект исследования}
        	}
        \end{flushright}
    \end{large}
	
	\begin{grayback}
	Объект исследования, как часто их путают, это не предмет и наука. Это область, в рамках которой лежит ваша тема.
	\end{grayback}
	
	Объектом исследования в этой работе является датасет с контентом, предоставленный сервисом Quora.
	
	
	Моя работа будет разбита на две смысловые части. В первой будет предложено архитектурное решение, которое будет организовывать работу с данными, используемую модель и другие основные сущности. Во второй мы подробнее рассмотрим частное применение архитектуры к вышеобозначенной задаче классификации.
	
    \begin{large}
        \begin{flushright}
        	\fbox{
        		\textbf{Обозначения}
        	}
        \end{flushright}
    \end{large}
	На протяжении всей работы я буду сопровождать текстовые выкладки иллюстрациями в виде блок-схем. Они будут состоять из следющих объектов:
	
	овал с неровными краями - необработанные данные.
	овал с ровными краями - обработанные данные.
	прямоугольник - программистская сущность.
	
    \begin{large}
        \begin{flushright}
        	\fbox{
        		\textbf{Часть 1}
        	}
        \end{flushright}
    \end{large}
    
    Простейший workflow, который мы представляем в голове, когда говорим о решении задачи по машинному обучению выглядит примерно таким образом: обычно у нас есть некоторый пулл данных, мы разделяем его на обучающую выборку для настройки выбранной модели и на тестовую для того, чтобы оценить качество полученного решения. Обозначим эти соображения в виде схемы:
    
    RAW -> Train, Test -> Model -> Prediction
    
    
    В более сложных задачах данные требуют некоторой обработки (например, фильтрация, семплирование или преобразование в совершенно другую форму). Давайте добавим эту сущность в нашу диаграмму:
    
    RAW -> Train, Test -> Data Transformer -> Model -> Prediction
    
    Зачастую, с некоторыми небольшими вариациями, на этой схеме останавливаются. Мы же пройдем немного дальше. Углубимся в детали, добавим некоторый новый расширяющий возможности функционал и постараемся сделать такую систему, которая бы легко масштабировалась на другие проекты, никак не связанные с нашей исходной задачей. 
    
    В первую очередь, заметим, что в процессе решения любой серьезной задачи перебирается несколько моделей и Data Transformer-ов. Давайте добавим их на схему:
    
    RAW -> Train, Test -> Data Transformer 1, Data Transformer 2, ... -> Model 1, Model 2, ... -> Prediction
    
    Еще одним нововведением предлагаю сделать сущность, которая бы осуществляла переход из RAW в Train и Test. Ведь иногда источников данных может быть много, иногда хочется фильтровать ненужные объекты как можно раньше и т.п. Назовем эту сущность Data Provider:
    
    RAW -> Data Provider -> Train, Test -> Data Transformer 1, Data Transformer 2, ... -> Model 1, Model 2, ... -> Prediction
	
	Теперь у нас получилась довольно простая в понимании, но пока что несколько сложная в реализации схема. Непонятно, что будет связующим звеном, кто собственно будет реализовывать эту схему и передавать данные дальше по цепочке. Давайте введем сущность, которая будет это все оркестрировать и назовем ее Launcher:
	
	
	                                                            Launcher: 
	                                                            
    RAW -> Data Provider -> Train, Test -> Data Transformer 1, Data Transformer 2, ... -> Model 1, Model 2, ... -> Prediction 
            
	Еще пара соображений, которые помогут нам упростить работу:

    -- JSON конфиги. Всегда есть огромное количество констант, с которыми необходимо работать. От путей до данных и соотношения train/test до глубины решающего дерева и коэффициентов регуляризации. Чтобы не бегать по всему коду и не искать где какая константа лежит, мы будем держать их всех в одном месте: в JSON конфиге, который будет передаваться в аргументах запуска Launcher.
    
    -- Логгирование. Важнейшим аспектом разработки любого продукта является создание исчерпывающей системы логгирования. Мы будем поддерживать два режима DEBUG и INFO. Ознакомиться с полным перечнем общеиспользуемых уровней логгирования и прочитать кейсы их применения можно вот здесь: https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels
	
	   \begin{large}
        \begin{flushright}
        	\fbox{
        		\textbf{Часть 2}
        	}
        \end{flushright}
    \end{large}
    
    Разберем подробнее задачу, которую поставила перед нами компания Quora. В первую очередь нас интересует пулл данных, которые разрешено использовать в рамках решения. Кроме стандартных train и test данных там есть довольно полезные подборки w2v словарей, собранных различными организациями: google news, glove, paragram, wiki-news.
    
    Таким образом, в нашей архитектуре мы уже можем довольно точно представить себе DataProvider: он довольно прост, ничего специфического: просто будет считывать train.csv и разделять на две внутренние train и test выборки. А вот в качестве XTransformer напрашивается следующий алгоритм: для всех слов из данных задачи мы сопоставим вектор, который будет конкатенацией векторов среди всех предоставленных нам словарей. Таким образом, выходной единицей трансформации будет вектор в некотором пространстве, который довольно неплохо будет характеризовать относительное семантическое положение слова.
    
    В качестве модели заебашим обычный керас + еще какую-то хуйню.
    
    \begin{large}
        \begin{flushright}
        	\fbox{
        		\textbf{Заключение}
        	}
        \end{flushright}
    \end{large}
    
    Итак, мы получили готовый коммерческий продукт, который обладает хорошей масштабируемостью, гибкостю и качественно решает поставленную задачу. Но, что на мой взгляд более важно, мы разработали обобщенную архитектуру для решения задач такого типа. Эту архитектуру я применял еще на нескольких kaggle контестах и везде получал досотойный результат. Че еще сказать, ну заебись архитектура, да.
    
    вот и все, ебать...
    
    
     \begin{large}
        \begin{flushright}
        	\fbox{
        		\textbf{Источники}
        	}
        \end{flushright}
    \end{large}
    
    \begin{itemize}
        \item Clean Code, Robert C. Martin Series
        \item Clean Architecture, Robert C. Martin Series
        \item The clean coder, Robert C. Martin Series
    \end{itemize}
	
\end{document}
